{"ast":null,"code":"import { ChaCha20Poly1305 as J } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as Ye } from \"@stablelib/hkdf\";\nimport { randomBytes as Q } from \"@stablelib/random\";\nimport { SHA256 as We, hash as Z } from \"@stablelib/sha256\";\nimport * as X from \"@stablelib/x25519\";\nimport { toString as l, fromString as f, concat as ee } from \"uint8arrays\";\nimport { detect as Je } from \"detect-browser\";\nimport { toMiliseconds as D, FIVE_MINUTES as ne, fromMiliseconds as Qe } from \"@walletconnect/time\";\nimport { getDocument as Ze, getNavigator as te, getLocation as re } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Xe } from \"@walletconnect/window-metadata\";\nimport * as P from \"query-string\";\nimport { RELAY_JSONRPC as en } from \"@walletconnect/relay-api\";\nconst T = \":\";\nfunction oe(e) {\n  const [n, t] = e.split(T);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction se(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(T);\n}\nfunction j(e) {\n  const [n, t, r] = e.split(T);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction ie(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(T);\n}\nfunction V(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction ce(e) {\n  const {\n    address: n\n  } = j(e);\n  return n;\n}\nfunction ae(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = j(e);\n  return se({\n    namespace: n,\n    reference: t\n  });\n}\nfunction nn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = oe(n);\n  return ie({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction tn(e) {\n  return V(e, ce);\n}\nfunction ue(e) {\n  return V(e, ae);\n}\nfunction rn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction on(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ue(o.accounts));\n  }), t;\n}\nfunction sn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...R(r, o));\n  }), t;\n}\nfunction R(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nconst U = e => e?.split(\":\"),\n  de = e => {\n    const n = e && U(e);\n    if (n) return n[3];\n  },\n  cn = e => {\n    const n = e && U(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  le = e => {\n    const n = e && U(e);\n    if (n) return n.pop();\n  },\n  an = (e, n) => {\n    const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n      r = le(n),\n      o = e.statement,\n      s = `URI: ${e.aud}`,\n      i = `Version: ${e.version}`,\n      a = `Chain ID: ${de(n)}`,\n      p = `Nonce: ${e.nonce}`,\n      y = `Issued At: ${e.iat}`,\n      m = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(c => `- ${c}`).join(`\n`)}` : void 0;\n    return [t, r, \"\", o, \"\", s, i, a, p, y, m].filter(c => c != null).join(`\n`);\n  },\n  M = \"base10\",\n  u = \"base16\",\n  A = \"base64pad\",\n  _ = \"utf8\",\n  K = 0,\n  b = 1,\n  un = 0,\n  fe = 1,\n  k = 12,\n  L = 32;\nfunction dn() {\n  const e = X.generateKeyPair();\n  return {\n    privateKey: l(e.secretKey, u),\n    publicKey: l(e.publicKey, u)\n  };\n}\nfunction ln() {\n  const e = Q(L);\n  return l(e, u);\n}\nfunction fn(e, n) {\n  const t = X.sharedKey(f(e, u), f(n, u)),\n    r = new Ye(We, t).expand(L);\n  return l(r, u);\n}\nfunction pn(e) {\n  const n = Z(f(e, u));\n  return l(n, u);\n}\nfunction mn(e) {\n  const n = Z(f(e, _));\n  return l(n, u);\n}\nfunction pe(e) {\n  return f(`${e}`, M);\n}\nfunction S(e) {\n  return Number(l(e, M));\n}\nfunction yn(e) {\n  const n = pe(typeof e.type < \"u\" ? e.type : K);\n  if (S(n) === b && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? f(e.senderPublicKey, u) : void 0,\n    r = typeof e.iv < \"u\" ? f(e.iv, u) : Q(k),\n    o = new J(f(e.symKey, u)).seal(r, f(e.message, _));\n  return me({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction En(e) {\n  const n = new J(f(e.symKey, u)),\n    {\n      sealed: t,\n      iv: r\n    } = F(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return l(o, _);\n}\nfunction me(e) {\n  if (S(e.type) === b) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return l(ee([e.type, e.senderPublicKey, e.iv, e.sealed]), A);\n  }\n  return l(ee([e.type, e.iv, e.sealed]), A);\n}\nfunction F(e) {\n  const n = f(e, A),\n    t = n.slice(un, fe),\n    r = fe;\n  if (S(t) === b) {\n    const a = r + L,\n      p = a + k,\n      y = n.slice(r, a),\n      m = n.slice(a, p),\n      c = n.slice(p);\n    return {\n      type: t,\n      sealed: c,\n      iv: m,\n      senderPublicKey: y\n    };\n  }\n  const o = r + k,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction gn(e, n) {\n  const t = F(e);\n  return ye({\n    type: S(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? l(t.senderPublicKey, u) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction ye(e) {\n  const n = e?.type || K;\n  if (n === b) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction hn(e) {\n  return e.type === b && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar Nn = Object.defineProperty,\n  Ee = Object.getOwnPropertySymbols,\n  vn = Object.prototype.hasOwnProperty,\n  bn = Object.prototype.propertyIsEnumerable,\n  ge = (e, n, t) => n in e ? Nn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  he = (e, n) => {\n    for (var t in n || (n = {})) vn.call(n, t) && ge(e, t, n[t]);\n    if (Ee) for (var t of Ee(n)) bn.call(n, t) && ge(e, t, n[t]);\n    return e;\n  };\nconst Ne = \"ReactNative\",\n  O = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  C = \" \",\n  On = \":\",\n  ve = \"/\",\n  x = 2,\n  Sn = 1e3,\n  be = \"js\";\nfunction H() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction Oe() {\n  return !Ze() && !!te() && navigator.product === Ne;\n}\nfunction Se() {\n  return !H() && !!te();\n}\nfunction q() {\n  return Oe() ? O.reactNative : H() ? O.node : Se() ? O.browser : O.unknown;\n}\nfunction Ie(e, n) {\n  let t = P.parse(e);\n  return t = he(he({}, t), n), e = P.stringify(t), e;\n}\nfunction In() {\n  return Xe() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Pn(e, n) {\n  var t;\n  const r = q(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = re()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Pe() {\n  const e = Je();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Te() {\n  var e;\n  const n = q();\n  return n === O.browser ? [n, ((e = re()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Re(e, n, t) {\n  const r = Pe(),\n    o = Te();\n  return [[e, n].join(\"-\"), [be, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction Tn(_ref) {\n  let {\n    protocol: e,\n    version: n,\n    relayUrl: t,\n    sdkVersion: r,\n    auth: o,\n    projectId: s,\n    useOnCloseEvent: i\n  } = _ref;\n  const a = t.split(\"?\"),\n    p = Re(e, n, r),\n    y = {\n      auth: o,\n      ua: p,\n      projectId: s,\n      useOnCloseEvent: i || void 0\n    },\n    m = Ie(a[1] || \"\", y);\n  return a[0] + \"?\" + m;\n}\nfunction Rn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Un(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Ue(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return Ae(e.split(ve), n);\n}\nfunction An(e) {\n  return Ue(e).join(C);\n}\nfunction g(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction Ae(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction _n(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Cn(e) {\n  return new Map(Object.entries(e));\n}\nfunction wn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst $n = e => e;\nfunction _e(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction Dn(e) {\n  return e.split(C).map(n => _e(n)).join(C);\n}\nfunction jn() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ne;\n  let n = arguments.length > 1 ? arguments[1] : undefined;\n  const t = D(e || ne);\n  let r, o, s;\n  return {\n    resolve: i => {\n      s && r && (clearTimeout(s), r(i));\n    },\n    reject: i => {\n      s && o && (clearTimeout(s), o(i));\n    },\n    done: () => new Promise((i, a) => {\n      s = setTimeout(() => {\n        a(new Error(n));\n      }, t), r = i, o = a;\n    })\n  };\n}\nfunction Vn(e, n) {\n  return new Promise(async (t, r) => {\n    const o = setTimeout(() => r(), n),\n      s = await e;\n    clearTimeout(o), t(s);\n  });\n}\nfunction B(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction Mn(e) {\n  return B(\"topic\", e);\n}\nfunction Kn(e) {\n  return B(\"id\", e);\n}\nfunction kn(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction Ln(e, n) {\n  return Qe((n || Date.now()) + D(e));\n}\nfunction Fn(e) {\n  return Date.now() >= D(e);\n}\nfunction xn(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nconst Ce = \"irn\";\nfunction Hn(e) {\n  return e?.relay || {\n    protocol: Ce\n  };\n}\nfunction qn(e) {\n  const n = en[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar Bn = Object.defineProperty,\n  we = Object.getOwnPropertySymbols,\n  Gn = Object.prototype.hasOwnProperty,\n  zn = Object.prototype.propertyIsEnumerable,\n  $e = (e, n, t) => n in e ? Bn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Yn = (e, n) => {\n    for (var t in n || (n = {})) Gn.call(n, t) && $e(e, t, n[t]);\n    if (we) for (var t of we(n)) zn.call(n, t) && $e(e, t, n[t]);\n    return e;\n  };\nfunction De(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction Wn(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = P.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: De(i)\n  };\n}\nfunction je(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction Jn(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + P.stringify(Yn({\n    symKey: e.symKey\n  }, je(e.relay)));\n}\nfunction N(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction Ve(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...N(t.accounts));\n  }), n;\n}\nfunction Me(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    N(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction Ke(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    N(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction Qn(e, n) {\n  const t = Be(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nconst Zn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Xn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction E(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Xn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction v(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Zn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction G(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction h(e) {\n  return typeof e > \"u\";\n}\nfunction d(e, n) {\n  return n && h(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction w(e, n) {\n  return n && h(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction et(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return g(o, r) ? (r.forEach(i => {\n    const {\n        accounts: a,\n        methods: p,\n        events: y\n      } = e.namespaces[i],\n      m = N(a),\n      c = t[i];\n    (!g(R(i, c), m) || !g(c.methods, p) || !g(c.events, y)) && (s = !1);\n  }), s) : !1;\n}\nfunction $(e) {\n  return d(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction ke(e) {\n  if (d(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && $(t);\n    }\n  }\n  return !1;\n}\nfunction nt(e) {\n  if (d(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction tt(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction rt(e) {\n  return e?.topic;\n}\nfunction ot(e, n) {\n  let t = null;\n  return d(e?.publicKey, !1) || (t = E(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction z(e) {\n  let n = !0;\n  return I(e) ? e.length && (n = e.every(t => d(t, !1))) : n = !1, n;\n}\nfunction Le(e, n, t) {\n  let r = null;\n  return I(n) ? n.forEach(o => {\n    r || (!$(o) || !o.includes(e)) && (r = v(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = v(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\nfunction Fe(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(_ref2 => {\n    let [r, o] = _ref2;\n    if (t) return;\n    const s = Le(r, R(r, o), `${n} requiredNamespace`);\n    s && (t = s);\n  }), t;\n}\nfunction xe(e, n) {\n  let t = null;\n  return I(e) ? e.forEach(r => {\n    t || ke(r) || (t = v(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = v(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction He(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = xe(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction qe(e, n) {\n  let t = null;\n  return z(e?.methods) ? z(e?.events) || (t = v(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = v(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction Y(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = qe(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction st(e, n, t) {\n  let r = null;\n  if (e && G(e)) {\n    const o = Y(e, n);\n    o && (r = o);\n    const s = Fe(e, n);\n    s && (r = s);\n  } else r = E(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n  return r;\n}\nfunction Be(e, n) {\n  let t = null;\n  if (e && G(e)) {\n    const r = Y(e, n);\n    r && (t = r);\n    const o = He(e, n);\n    o && (t = o);\n  } else t = E(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction Ge(e) {\n  return d(e.protocol, !0);\n}\nfunction it(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(r => {\n    t = Ge(r);\n  }), t;\n}\nfunction ct(e) {\n  return typeof e == \"number\";\n}\nfunction at(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction ut(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !w(e.code, !1) || !e.message || !d(e.message, !1));\n}\nfunction dt(e) {\n  return !(h(e) || !d(e.method, !1));\n}\nfunction lt(e) {\n  return !(h(e) || h(e.result) && h(e.error) || !w(e.id, !1) || !d(e.jsonrpc, !1));\n}\nfunction ft(e) {\n  return !(h(e) || !d(e.name, !1));\n}\nfunction pt(e, n) {\n  return !(!$(n) || !Ve(e).includes(n));\n}\nfunction mt(e, n, t) {\n  return d(t, !1) ? Me(e, n).includes(t) : !1;\n}\nfunction yt(e, n, t) {\n  return d(t, !1) ? Ke(e, n).includes(t) : !1;\n}\nfunction Et(e, n, t) {\n  let r = null;\n  const o = gt(e),\n    s = ht(n),\n    i = Object.keys(o),\n    a = Object.keys(s),\n    p = ze(Object.keys(e)),\n    y = ze(Object.keys(n)),\n    m = p.filter(c => !y.includes(c));\n  return m.length && (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${m.toString()}\n      Received: ${Object.keys(n).toString()}`)), g(i, a) || (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${a.toString()}`)), Object.keys(n).forEach(c => {\n    if (!c.includes(\":\") || r) return;\n    const W = N(n[c].accounts);\n    W.includes(c) || (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${c}\n        Required: ${c}\n        Approved: ${W.toString()}`));\n  }), i.forEach(c => {\n    r || (g(o[c].methods, s[c].methods) ? g(o[c].events, s[c].events) || (r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${c}`)) : r = E(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${c}`));\n  }), r;\n}\nfunction gt(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\nfunction ze(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\nfunction ht(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = N(e[t].accounts);\n      r?.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\nfunction Nt(e, n) {\n  return w(e, !1) && e <= n.max && e >= n.min;\n}\nexport { M as BASE10, u as BASE16, A as BASE64, On as COLON, x as DEFAULT_DEPTH, C as EMPTY_SPACE, O as ENV_MAP, Sn as ONE_THOUSAND, Ne as REACT_NATIVE_PRODUCT, Ce as RELAYER_DEFAULT_PROTOCOL, be as SDK_TYPE, ve as SLASH, K as TYPE_0, b as TYPE_1, _ as UTF8, Ie as appendToQueryString, Un as assertType, Ln as calcExpiry, Dn as capitalize, _e as capitalizeWord, jn as createDelayedPromise, Vn as createExpiringPromise, S as decodeTypeByte, En as decrypt, fn as deriveSymKey, F as deserialize, pe as encodeTypeByte, yn as encrypt, xn as engineEvent, $n as enumify, ie as formatAccountId, nn as formatAccountWithChain, se as formatChainId, B as formatExpirerTarget, Kn as formatIdTarget, an as formatMessage, An as formatMessageContext, je as formatRelayParams, Tn as formatRelayRpcUrl, Mn as formatTopicTarget, Re as formatUA, Jn as formatUri, dn as generateKeyPair, ln as generateRandomBytes32, N as getAccountsChains, rn as getAccountsFromNamespaces, ce as getAddressFromAccount, tn as getAddressesFromAccounts, In as getAppMetadata, ae as getChainFromAccount, ue as getChainsFromAccounts, R as getChainsFromNamespace, on as getChainsFromNamespaces, sn as getChainsFromRequiredNamespaces, le as getDidAddress, U as getDidAddressSegments, de as getDidChainId, q as getEnvironment, Rn as getHttpUrl, E as getInternalError, Te as getJavascriptID, Pe as getJavascriptOS, Ae as getLastItems, cn as getNamespacedDidChainId, Ve as getNamespacesChains, Ke as getNamespacesEventsForChainId, Me as getNamespacesMethodsForChainId, Pn as getRelayClientMetadata, qn as getRelayProtocolApi, Hn as getRelayProtocolName, Qn as getRequiredNamespacesFromNamespaces, v as getSdkError, V as getUniqueValues, g as hasOverlap, pn as hashKey, mn as hashMessage, Se as isBrowser, Et as isConformingNamespaces, Fn as isExpired, H as isNode, tt as isProposalStruct, Oe as isReactNative, et as isSessionCompatible, rt as isSessionStruct, hn as isTypeOneEnvelope, h as isUndefined, ke as isValidAccountId, xe as isValidAccounts, qe as isValidActions, I as isValidArray, $ as isValidChainId, Le as isValidChains, ot as isValidController, ut as isValidErrorReason, ft as isValidEvent, ct as isValidId, He as isValidNamespaceAccounts, Y as isValidNamespaceActions, Fe as isValidNamespaceChains, z as isValidNamespaceMethodsOrEvents, Be as isValidNamespaces, pt as isValidNamespacesChainId, yt as isValidNamespacesEvent, mt as isValidNamespacesRequest, w as isValidNumber, G as isValidObject, at as isValidParams, Ge as isValidRelay, it as isValidRelays, dt as isValidRequest, Nt as isValidRequestExpiry, st as isValidRequiredNamespaces, lt as isValidResponse, d as isValidString, nt as isValidUrl, wn as mapEntries, _n as mapToObj, Cn as objToMap, j as parseAccountId, oe as parseChainId, Ue as parseContextNames, kn as parseExpirerTarget, De as parseRelayParams, Wn as parseUri, me as serialize, gn as validateDecoding, ye as validateEncoding };","map":{"version":3,"names":[],"sources":["C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\caip.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\cacao.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\crypto.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\misc.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\relay.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\uri.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\namespaces.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\errors.ts","C:\\Users\\dell\\OneDrive\\Desktop\\Mudex-Latest\\mudex\\node_modules\\@walletconnect\\utils\\src\\validators.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","export interface CacaoPayload {\n  iss: string;\n  domain: string;\n  aud: string;\n  version: string;\n  nonce: string;\n  iat: string;\n  nbf?: string;\n  exp?: string;\n  statement?: string;\n  requestId?: string;\n  resources?: string[];\n}\n\nexport interface CacaoHeader {\n  t: \"eip4361\";\n}\n\nexport interface CacaoSignature {\n  t: \"eip191\" | \"eip1271\";\n  s: string;\n  m?: string;\n}\n\nexport interface Cacao {\n  h: CacaoHeader;\n  p: CacaoPayload;\n  s: CacaoSignature;\n}\n\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[3];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport const formatMessage = (cacao: CacaoPayload, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n  const statement = cacao.statement;\n  const uri = `URI: ${cacao.aud}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const resources =\n    cacao.resources && cacao.resources.length > 0\n      ? `Resources:\\n${cacao.resources.map((resource) => `- ${resource}`).join(\"\\n\")}`\n      : undefined;\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize(params.encoded);\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(encoded: string): CryptoTypes.EncodingParams {\n  const bytes = fromString(encoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize(encoded);\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\n\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n  useOnCloseEvent,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = { auth, ua, projectId, useOnCloseEvent: useOnCloseEvent || undefined };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(\n  expiry: number = FIVE_MINUTES,\n  expireErrorMessage?: string,\n) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      cacheTimeout = setTimeout(() => {\n        promiseReject(new Error(expireErrorMessage));\n      }, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(promise: Promise<T>, expiry: number) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(), expiry);\n    const res = await promise;\n    clearTimeout(timeout);\n    resolve(res);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return Date.now() >= toMiliseconds(expiry);\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const result = {\n    protocol,\n    topic: requiredValues[0],\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n  };\n  return result;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n    })\n  );\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { isValidNamespaces } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n","/**\n * Types\n */\ntype SdkErrorKey = keyof typeof SDK_ERRORS;\ntype InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nconst SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nconst INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { hasOverlap } from \"./misc\";\nimport { getChainsFromNamespace } from \"./caip\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  if (isValidString(value, false)) {\n    try {\n      const url = new URL(value);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(chains)) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain) || !chain.includes(key)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains ${chains} should be an array of strings conforming to \"namespace:chainId\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} requiredNamespace`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}